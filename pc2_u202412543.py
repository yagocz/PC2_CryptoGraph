# -*- coding: utf-8 -*-
"""PC2_U202412543.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xKR22-I3KAsFfDOwbQpk8FjhjDNCSY8c
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# Visualización
pd.set_option('display.float_format', lambda x: '%.4f' % x)

# Cargar dataset
df = pd.read_csv("crypto-markets.csv")

print("Dimensiones iniciales:", df.shape)
print("Columnas:", df.columns.tolist())

# Vista rápida
display(df.head())

# Conversión de tipos

# Convertir fechas
df['date'] = pd.to_datetime(df['date'], errors='coerce')

# Asegurar que las métricas numéricas sean numéricas
num_cols = ['ranknow','open','high','low','close','volume','market',
            'close_ratio','spread']
for col in num_cols:
    df[col] = pd.to_numeric(df[col], errors='coerce')

# Valores nulos
nulls = df.isna().mean().sort_values(ascending=False)
print("\nPorcentaje de nulos por columna:")
print(nulls)

df = df.dropna(subset=['close','symbol','date']).reset_index(drop=True)

df['volume'] = df['volume'].fillna(0)
df['market'] = df['market'].fillna(0)

# Duplicados
# Debe haber 1 registro por día y símbolo
before = len(df)
df = df.drop_duplicates(subset=['symbol','date'])
after = len(df)
print(f"\nDuplicados eliminados: {before - after}")

# Análisis exploratorio básico
print("\nResumen numérico:")
display(df[num_cols].describe().T)

print("\nCriptomonedas únicas:", df['symbol'].nunique())
print("Rango temporal:", df['date'].min(), "→", df['date'].max())

# Distribución de monedas por número de días
days_per_coin = df.groupby('symbol')['date'].nunique().sort_values(ascending=False)
print("\nTop monedas con más días de data:")
print(days_per_coin.head(10))

# Outliers (rangos extremos)

# Usaremos log-transform para detectar outliers en volumen y market
for col in ['volume','market','close']:
    plt.figure(figsize=(6,3))
    sns.boxplot(x=np.log1p(df[col]))
    plt.title(f"Boxplot log1p({col})")
    plt.show()

# Filtrar outliers extremos: top 0.5% en volumen/market
for col in ['volume','market']:
    high = df[col].quantile(0.995)
    df = df[df[col] <= high]

print("\nDimensiones tras filtrar outliers:", df.shape)

# Variables derivadas
# Volatilidad diaria
df['daily_range'] = df['high'] - df['low']
df['daily_pct_change'] = (df['close'] - df['open']) / df['open']

# Ratio volumen/market
df['volume_ratio'] = df.apply(lambda x: x['volume']/x['market'] if x['market']>0 else 0, axis=1)

# Precio normalizado (por moneda)
df['close_norm'] = df.groupby('symbol')['close'].transform(
    lambda x: (x - x.min()) / (x.max() - x.min())
)

# Estadísticas finales
summary = df.groupby('symbol').agg({
    'close':'mean',
    'volume':'mean',
    'market':'mean',
    'daily_range':'mean',
    'volume_ratio':'mean'
}).rename(columns={
    'close':'price_mean',
    'volume':'volume_mean',
    'market':'market_mean',
    'daily_range':'range_mean',
    'volume_ratio':'vol_ratio_mean'
}).reset_index()

print("\nResumen por moneda (primeras filas):")
display(summary.head())

# Guardar dataset limpio

df.to_csv("crypto_markets_clean.csv", index=False)
summary.to_csv("crypto_summary_clean.csv", index=False)
print("\nArchivos generados:")
print(" - crypto_markets_clean.csv (dataset diario limpio)")
print(" - crypto_summary_clean.csv (estadísticas por moneda)")

print("Nodos después de limpieza:",
      df['symbol'].nunique())

import pandas as pd
import networkx as nx
from pyvis.network import Network
import numpy as np

# Cargar dataset limpio
df = pd.read_csv("crypto_markets_clean.csv")

#  criptomonedas únicas
print("Total de criptomonedas únicas:", df['symbol'].nunique())

# Tomar la última fecha disponible de cada moneda
latest = df.sort_values('date').groupby('symbol').tail(1)

#Grafo
G = nx.Graph()

# Nodos: cada criptomoneda
# tamaño = log(market)
for _, row in latest.iterrows():
    market = row['market'] if row['market'] > 0 else 1
    size = np.log1p(market) * 2      # escalado log
    G.add_node(
        row['symbol'],
        title=f"""
        <b>{row['name']}</b><br>
        Precio USD: {row['close']:.4f}<br>
        Market Cap: {row['market']:.0f}<br>
        Volumen: {row['volume']:.0f}
        """,
        group="General",   # todos en un solo grupo
        value=size
    )

# aristas: relación por correlación de precio con otras monedas
# Usamos una muestra de 200 monedas con mayor market para no sobrecargar
top_coins = latest.sort_values('market', ascending=False).head(200)['symbol']
sub_df = df[df['symbol'].isin(top_coins)]

# pivot para correlaciones de precios normalizados
pivot = sub_df.pivot(index='date', columns='symbol', values='close_norm').fillna(0)
corr = pivot.corr()

threshold = 0.75  # umbral de correlación para conectar
for c1 in top_coins:
    for c2 in top_coins:
        if c1 != c2 and corr.loc[c1, c2] > threshold:
            G.add_edge(c1, c2, weight=float(corr.loc[c1, c2]))

#
# Visualización PyVis
#
net = Network(
    notebook=True,
    height="750px",
    width="100%",
    bgcolor="#1e1e1e",
    font_color="white"
)

# configuracin para una mejor visualizacion
net.barnes_hut(
    gravity=-8000,
    spring_length=150,
    spring_strength=0.02,
    central_gravity=0.3,
    damping=0.7
)

net.from_nx(G)
net.show("crypto_network.html")